{"version":3,"file":"content.js","mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACxOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7wBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AClgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AENA;AACA;AACA;AACA","sources":["webpack://front/./node_modules/leafstore-db/index.js","webpack://front/./node_modules/leafstore-db/src/document.js","webpack://front/./node_modules/leafstore-db/src/leafstore.js","webpack://front/./node_modules/leafstore-db/src/model.js","webpack://front/./node_modules/leafstore-db/src/schema.js","webpack://front/./src/content.js","webpack://front/webpack/bootstrap","webpack://front/webpack/runtime/async module","webpack://front/webpack/runtime/define property getters","webpack://front/webpack/runtime/hasOwnProperty shorthand","webpack://front/webpack/runtime/make namespace object","webpack://front/webpack/before-startup","webpack://front/webpack/startup","webpack://front/webpack/after-startup"],"sourcesContent":["import leafstore from \"./src/leafstore.js\";\r\n\r\nexport default leafstore;\r\n","// const LeafstoreModel = require(\"./model\");\r\nimport LeafstoreModel from \"./model.js\";\r\n\r\n/**\r\n * @template {Record<string, any>} T\r\n * @class\r\n */\r\nclass LeafstoreDocument {\r\n  /**\r\n   * Creates a Leafstore document. This class is not meant to be instantiated directly.\r\n   * {@link LeafstoreModel} will call this class automatically for you.\r\n   *\r\n   * @param {T} object\r\n   * @param {LeafstoreModel<T>} model\r\n   * @param {Boolean} [isNew=true]\r\n   */\r\n  constructor(object, model, isNew = true) {\r\n    this._object = object;\r\n    this._model = model;\r\n    this._isNew = isNew;\r\n\r\n    this.#addGettersAndSetters();\r\n  }\r\n\r\n  /**\r\n   * Adds getters and setters to the document\r\n   */\r\n  #addGettersAndSetters() {\r\n    /** @type {Record<keyof T, any>} */\r\n    const schema = this._model._schema._schema;\r\n    const privateFields = [\"_key\"];\r\n\r\n    for (let key in schema) {\r\n      if (this._object.hasOwnProperty(key)) {\r\n        // add only getters for private fields\r\n        if (privateFields.includes(key)) {\r\n          Object.defineProperty(this, key, {\r\n            get() {\r\n              return this._object[key];\r\n            },\r\n          });\r\n          continue;\r\n        }\r\n        // add getters and setters\r\n        Object.defineProperty(this, key, {\r\n          get() {\r\n            return this._object[key];\r\n          },\r\n          set(value) {\r\n            this._isNew = true;\r\n            this._object[key] = value;\r\n          },\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @returns {String}\r\n   */\r\n  toString() {\r\n    return JSON.stringify(this._object);\r\n  }\r\n\r\n  /**\r\n   * @returns {Object}\r\n   */\r\n  toJSON() {\r\n    return this._object;\r\n  }\r\n\r\n  /**\r\n   * Saves the document to the database. If the document is new, it will be created.\r\n   * @returns {Promise<LeafstoreDocument<T>>}\r\n   */\r\n  async save() {\r\n    if (!this._isNew) {\r\n      return this;\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        this._model.insertOne(this._object, this._object._key).then((document) => {\r\n          this._object = document._object;\r\n          this._isNew = false;\r\n          resolve(this);\r\n        }).catch((error) => {\r\n          reject(error);\r\n        });\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n// module.exports = LeafstoreDocument;\r\nexport default LeafstoreDocument;\r\n","// const LeafstoreSchema = require(\"./schema.js\");\r\n// const LeafstoreModel = require(\"./model.js\");\r\nimport LeafstoreSchema from \"./schema.js\";\r\nimport LeafstoreModel from \"./model.js\";\r\n\r\nclass leafstore {\r\n  /**\r\n   * Creates a leafstore database\r\n   * @param {String} dbName\r\n   */\r\n  constructor(dbName) {\r\n    if (!dbName) throw new Error(\"dbName is required\");\r\n    if (typeof dbName !== \"string\") throw new Error(\"dbName must be a string\");\r\n    /** @type {String} */\r\n    this.dbName = dbName;\r\n    /** @type {IDBDatabase | null} */\r\n    this._db = null;\r\n    /** @type {Record<string, LeafstoreModel>} */\r\n    this._models = {};\r\n    /** @type {Number} */\r\n    this.version = 1;\r\n  }\r\n\r\n  static SchemaTypes = {\r\n    String: \"string\",\r\n    Number: \"number\",\r\n    Boolean: \"boolean\",\r\n    Date: \"date\",\r\n    Array: \"array\",\r\n    Object: \"object\",\r\n  };\r\n\r\n  /**\r\n   * @typedef {Object} LeafstoreConnectOptions\r\n   * @property {Number} [version] - The version of the database.\r\n   * @property {Function} [onUpgrade] - A function to run when the database is upgraded.\r\n   */\r\n\r\n  /**\r\n   * Connects to the database. This method must be called before using the database.\r\n   * This method will create the database if it doesn't exist, and upgrade it if the version is different.\r\n   * Make sure to define all your models before calling this method.\r\n   * @param {LeafstoreConnectOptions} options - optional\r\n   * @returns {Promise<leafstore>}\r\n   */\r\n  async connect(\r\n    options = {\r\n      version: 1,\r\n      onUpgrade: () => {},\r\n    }\r\n  ) {\r\n    return new Promise((resolve, reject) => {\r\n      const request = window.indexedDB.open(\r\n        this.dbName,\r\n        options.version || this.version\r\n      );\r\n      request.onupgradeneeded = (e) => {\r\n        this._db = request.result;\r\n\r\n        // create object store for schemas\r\n        const schemaStore = this._db.createObjectStore(\"schemas\", {\r\n          keyPath: \"name\",\r\n        });\r\n        schemaStore.createIndex(\"name\", \"name\", { unique: true });\r\n\r\n        // store schemas in the database\r\n        for (let key in this._models) {\r\n          if (this._models.hasOwnProperty(key)) {\r\n            schemaStore.add({\r\n              name: key,\r\n              schema: this._models[key]._schema._rawSchema,\r\n            });\r\n          }\r\n        }\r\n\r\n        // create object stores for models\r\n        for (let key in this._models) {\r\n          if (this._models.hasOwnProperty(key)) {\r\n            this.#generateObjectStore(this._models[key]);\r\n          }\r\n        }\r\n\r\n        if (typeof options.onUpgrade === \"function\") {\r\n          options.onUpgrade(this);\r\n        }\r\n      };\r\n      request.onsuccess = (e) => {\r\n        this._db = request.result;\r\n        this.version = this._db.version;\r\n\r\n        // get schemas from database\r\n        const transaction = this._db.transaction(\"schemas\", \"readonly\");\r\n        const schemaStore = transaction.objectStore(\"schemas\");\r\n        const schemaRequest = schemaStore.getAll();\r\n        schemaRequest.onsuccess = (e) => {\r\n          const schemas = schemaRequest.result;\r\n          for (let schema of schemas) {\r\n            this._models[schema.name] = new LeafstoreModel(\r\n              schema.name,\r\n              new LeafstoreSchema(schema.schema),\r\n              {\r\n                db: this._db,\r\n              }\r\n            );\r\n          }\r\n        };\r\n\r\n        // assign db to models\r\n        for (let key in this._models) {\r\n          if (this._models.hasOwnProperty(key)) {\r\n            this._models[key]._db = this._db;\r\n          }\r\n        }\r\n\r\n        resolve(this);\r\n      };\r\n      request.onerror = (e) => {\r\n        reject(request.error);\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Generates an object store for a model\r\n   * @param {LeafstoreModel} model\r\n   * @returns {void}\r\n   */\r\n  #generateObjectStore(model) {\r\n    const { _objectStoreName: objectStoreName, _schema } = model;\r\n\r\n    if (!this._db) throw new Error(\"Database is not connected\");\r\n\r\n    const objectStore = this._db.createObjectStore(objectStoreName, {\r\n      keyPath: \"_key\",\r\n    });\r\n    // create indexes for object store fields\r\n    this.#generateIndexes(objectStore, _schema);\r\n  }\r\n\r\n  /**\r\n   * Generates indexes for an object store\r\n   * @param {IDBObjectStore} objectStore - The object store to generate indexes for\r\n   * @param {LeafstoreSchema} schema - The schema of the object store\r\n   * @returns {void}\r\n   */\r\n  #generateIndexes(objectStore, schema) {\r\n    const _schema = schema._schema;\r\n    // flatten the object\r\n    // don't flatten arrays\r\n    const flatten = (obj, prefix = \"\") =>\r\n      Object.keys(obj).reduce((acc, k) => {\r\n        const pre = prefix.length ? `${prefix}.` : \"\";\r\n        if (\r\n          typeof obj[k] === \"object\" &&\r\n          (obj[k]._type === null || obj[k]._type === undefined)\r\n        )\r\n          assign(acc, flatten(obj[k], `${pre + k}`));\r\n        else acc[`${pre + k}`] = obj[k];\r\n        return acc;\r\n      }, {});\r\n\r\n    const assign = (obj, src) => {\r\n      Object.keys(src).forEach((key) => (obj[key] = src[key]));\r\n      return obj;\r\n    };\r\n\r\n    const flattenedSchema = flatten(_schema);\r\n\r\n    for (let key in flattenedSchema) {\r\n      if (flattenedSchema.hasOwnProperty(key)) {\r\n        const value = flattenedSchema[key];\r\n        // create index for field if unique\r\n        if (value?._unique) {\r\n          objectStore.createIndex(key, key, { unique: true });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @typedef {Object} LeafstoreSchemaOptions\r\n   */\r\n\r\n  /**\r\n   * creates a leafstore schema\r\n   * @template {Record<string, any>} T\r\n   * @param {T & { _key: string }} object\r\n   * @param {LeafstoreSchemaOptions} options - optional\r\n   * @returns {LeafstoreSchema<T & { _key: string }>}\r\n   */\r\n  static Schema(object, options = {}) {\r\n    if (!object) throw new Error(\"schema object is required\");\r\n    if (typeof object !== \"object\")\r\n      throw new Error(\"schema object must be of type 'object'\");\r\n\r\n    return new LeafstoreSchema(object, options);\r\n  }\r\n\r\n  /**\r\n   * creates a leafstore model\r\n   * @template {Record<string, any>} T\r\n   * @param {String} name\r\n   * @param {LeafstoreSchema<T>} schema\r\n   * @returns {LeafstoreModel<T>}\r\n   */\r\n  Model(name, schema) {\r\n    if (!name) throw new Error(\"Name is required\");\r\n    if (typeof name !== \"string\") throw new Error(\"Name must be a string\");\r\n    if (this._models[name]) return this._models[name];\r\n    if (!schema) throw new Error(\"Schema is required\");\r\n    if (!(schema instanceof LeafstoreSchema)) {\r\n      throw new Error(\"schema must be an instance of LeafstoreSchema\");\r\n    }\r\n\r\n    // pluralise name for object store name\r\n    const pluralise = (word) => {\r\n      if (word.endsWith(\"s\")) return word;\r\n      return word + \"s\";\r\n    };\r\n    const objectStoreName = pluralise(name.toLowerCase());\r\n\r\n    // TODO: create a model\r\n    this._models[name] = new LeafstoreModel(name, schema, {\r\n      db: this._db,\r\n      objectStoreName,\r\n    });\r\n\r\n    return this._models[name];\r\n  }\r\n}\r\n\r\n// module.exports = leafstore;\r\nexport default leafstore;\r\n","// const LeafstoreSchema = require(\"./schema.js\");\r\n// const LeafstoreDocument = require(\"./document.js\");\r\nimport LeafstoreSchema from \"./schema.js\";\r\nimport LeafstoreDocument from \"./document.js\";\r\n\r\n/**\r\n * @typedef {Object} LeafstoreModelConfig\r\n * @property {IDBDatabase | null} [db] - The database to use.\r\n * @property {String | null} [objectStoreName] - The name of the object store.\r\n */\r\n\r\n/**\r\n * @template {Record<string, any>} T\r\n * @class\r\n */\r\nclass LeafstoreModel {\r\n  /**\r\n   * Creates a leafstore model\r\n   * @param {String} name\r\n   * @param {LeafstoreSchema<T>} schema\r\n   * @param {LeafstoreModelConfig} config - optional\r\n   */\r\n  constructor(\r\n    name,\r\n    schema,\r\n    config = {\r\n      db: null,\r\n      objectStoreName: null,\r\n    }\r\n  ) {\r\n    if (!name) throw new Error(\"Name is required\");\r\n    if (typeof name !== \"string\") throw new Error(\"Name must be a string\");\r\n    if (!schema) throw new Error(\"Schema is required\");\r\n    if (!(schema instanceof LeafstoreSchema)) {\r\n      throw new Error(\"schema must be an instance of LeafstoreSchema\");\r\n    }\r\n    this.name = name;\r\n    this._schema = schema;\r\n    this._db = config.db;\r\n    this._objectStoreName = config.objectStoreName || name.toLowerCase();\r\n    this._deletedKeys = []; // keys of deleted documents - acts as a cache until the document is actually deleted\r\n  }\r\n\r\n  /**\r\n   * Creates a new document\r\n   * @param {Object} object\r\n   * @returns {Promise<LeafstoreDocument<T>>}\r\n   */\r\n  async create(object) {\r\n    // wait for the database to connect\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        if (!this._db) throw new Error(\"Database is not connected\");\r\n        // validate and cast object\r\n        this._schema.validate(object);\r\n        object = this._schema.cast(object);\r\n        // add unique key to object\r\n        this.#addUniqueKey(object);\r\n        // create object\r\n        const transaction = this._db.transaction(\r\n          this._objectStoreName,\r\n          \"readwrite\"\r\n        );\r\n        const objectStore = transaction.objectStore(this._objectStoreName);\r\n        const request = objectStore.add(object);\r\n        request.onsuccess = (e) => {\r\n          resolve(new LeafstoreDocument(object, this, false));\r\n        };\r\n        request.onerror = (e) => {\r\n          reject(request.error);\r\n        };\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Inserts a document. If the document already exists, it is updated.\r\n   * @param {Object} object\r\n   * @param {String} key\r\n   * @returns {Promise<LeafstoreDocument<T>>}\r\n   */\r\n  async insertOne(object, key) {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        if (!this._db) throw new Error(\"Database is not connected\");\r\n        // validate and cast object\r\n        this._schema.validate(object);\r\n        object = this._schema.cast(object);\r\n        // add unique key to object if not provided\r\n        // it means the object is new\r\n        if (!key && !object._key) {\r\n          this.#addUniqueKey(object);\r\n          key = object._key;\r\n        }\r\n        // create object\r\n        const transaction = this._db.transaction(\r\n          this._objectStoreName,\r\n          \"readwrite\"\r\n        );\r\n        const objectStore = transaction.objectStore(this._objectStoreName);\r\n        const request = objectStore.put(object);\r\n        request.onsuccess = (e) => {\r\n          resolve(new LeafstoreDocument(object, this, false));\r\n        };\r\n        request.onerror = (e) => {\r\n          reject(request.error);\r\n        };\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Finds a document by its primary key\r\n   * @param {String} key\r\n   * @returns {Promise<LeafstoreDocument<T> | null>}\r\n   */\r\n  async findByKey(key) {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        if (!this._db) throw new Error(\"Database is not connected\");\r\n\r\n        if (!key) throw new Error(\"Key is required\");\r\n        const transaction = this._db.transaction(\r\n          this._objectStoreName,\r\n          \"readonly\"\r\n        );\r\n        const objectStore = transaction.objectStore(this._objectStoreName);\r\n        const request = objectStore.get(key);\r\n        request.onsuccess = (e) => {\r\n          let result = request.result;\r\n          if (result) {\r\n            [result] = this.#filterDeleted([result]);\r\n            if (result) {\r\n              return resolve(new LeafstoreDocument(result, this, false));\r\n            }\r\n          }\r\n          resolve(null);\r\n        };\r\n        request.onerror = () => {\r\n          reject(request.error);\r\n        };\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Finds the first document matching the query.\r\n   * If no query is provided, the first document to come up is returned.\r\n   * Order is not guaranteed.\r\n   * @param {Object | IDBValidKey | IDBKeyRange | null} [query] - The query to match.\r\n   * @returns {Promise<LeafstoreDocument<T> | null>}\r\n   */\r\n  async findOne(query) {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        if (!this._db) throw new Error(\"Database is not connected\");\r\n\r\n        // Optimisation for primary key queries\r\n        let objectStoreName = this._objectStoreName;\r\n        let idbQuery = null;\r\n        if (typeof query === \"string\") {\r\n          idbQuery = query;\r\n        }\r\n        // optimisation ends\r\n        const transaction = this._db.transaction(objectStoreName, \"readonly\");\r\n        const objectStore = transaction.objectStore(this._objectStoreName);\r\n        const request = objectStore.getAll(idbQuery);\r\n        request.onsuccess = (e) => {\r\n          const result = request.result;\r\n          if (result) {\r\n            const document = this.#parseQuery(query, result, true);\r\n            if (document) {\r\n              resolve(new LeafstoreDocument(document, this, false));\r\n            } else {\r\n              resolve(null);\r\n            }\r\n          } else {\r\n            resolve(null);\r\n          }\r\n        };\r\n        request.onerror = (e) => {\r\n          reject(request.error);\r\n        };\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Finds all documents matching the query\r\n   * if no query is provided, all documents are returned\r\n   * @param {Object | IDBValidKey | IDBKeyRange | null} [query] - The query to match.\r\n   * @returns {Promise<LeafstoreDocument<T>[]>}\r\n   * @example\r\n   * // find all documents\r\n   * const documents = await User.find();\r\n   *\r\n   * // find all documents with the name 'John Doe'\r\n   * const documents = await User.find({ name: 'John Doe' });\r\n   *\r\n   * // find all documents with the name 'John Doe' and age 20\r\n   * const documents = await User.find({ name: 'John Doe', age: 20 });\r\n   *\r\n   * // find all documents with the name 'John Doe' and age greater than 20\r\n   * const documents = await User.find({ name: 'John Doe', age: { $gt: 20 } });\r\n   */\r\n  async find(query) {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        if (!this._db) throw new Error(\"Database is not connected\");\r\n\r\n        // Optimisation for primary key queries\r\n        let objectStoreName = this._objectStoreName;\r\n        let idbQuery = null;\r\n        if (typeof query === \"string\") {\r\n          idbQuery = query;\r\n        }\r\n        // optimisation ends\r\n        const transaction = this._db.transaction(objectStoreName, \"readonly\");\r\n        const objectStore = transaction.objectStore(this._objectStoreName);\r\n        const request = objectStore.getAll(idbQuery);\r\n        request.onsuccess = (e) => {\r\n          const result = request.result;\r\n          if (result) {\r\n            const documents = this.#parseQuery(query, result);\r\n            resolve(\r\n              documents.map(\r\n                (object) => new LeafstoreDocument(object, this, false)\r\n              )\r\n            );\r\n          } else {\r\n            resolve([]);\r\n          }\r\n        };\r\n        request.onerror = (e) => {\r\n          reject(request.error);\r\n        };\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Deletes a document by its primary key\r\n   * @param {String} key\r\n   * @returns {Promise<void>}\r\n   */\r\n  async findByKeyAndDelete(key) {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        if (!this._db) throw new Error(\"Database is not connected\");\r\n\r\n        if (!key) throw new Error(\"Key is required\");\r\n        const transaction = this._db.transaction(\r\n          this._objectStoreName,\r\n          \"readwrite\"\r\n        );\r\n        const objectStore = transaction.objectStore(this._objectStoreName);\r\n        const request = objectStore.delete(key);\r\n        request.onsuccess = () => {\r\n          resolve();\r\n        };\r\n        request.onerror = () => {\r\n          reject(request.error);\r\n        };\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Deletes the first document matching the query\r\n   * @param {Object | IDBValidKey | IDBKeyRange | null} [query] - The query to match.\r\n   * @returns {Promise<void>}\r\n   */\r\n  async deleteOne(query) {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        if (!this._db) throw new Error(\"Database is not connected\");\r\n\r\n        // Optimisation for primary key queries\r\n        let objectStoreName = this._objectStoreName;\r\n        let idbQuery = null;\r\n        if (typeof query === \"string\") {\r\n          idbQuery = query;\r\n        }\r\n        // optimisation ends\r\n        const transaction = this._db.transaction(\r\n          this._objectStoreName,\r\n          \"readwrite\"\r\n        );\r\n        const objectStore = transaction.objectStore(this._objectStoreName);\r\n        const request = objectStore.getAll(idbQuery);\r\n        request.onsuccess = () => {\r\n          const result = request.result;\r\n          if (result) {\r\n            const document = this.#parseQuery(query, result, true);\r\n            if (document) {\r\n              const key = document._key;\r\n              // delete document\r\n              this.#deleteByKey(key);\r\n            }\r\n          }\r\n          resolve();\r\n        };\r\n        request.onerror = () => {\r\n          reject(request.error);\r\n        };\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Deletes all documents matching the query\r\n   * @param {Object | IDBValidKey | IDBKeyRange | null} [query] - The query to match.\r\n   * @returns {Promise<void>}\r\n   */\r\n  async deleteMany(query) {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        if (!this._db) throw new Error(\"Database is not connected\");\r\n\r\n        // Optimisation for primary key queries\r\n        let objectStoreName = this._objectStoreName;\r\n        let idbQuery = null;\r\n        if (typeof query === \"string\") {\r\n          idbQuery = query;\r\n        }\r\n        // optimisation ends\r\n        const transaction = this._db.transaction(\r\n          this._objectStoreName,\r\n          \"readwrite\"\r\n        );\r\n        const objectStore = transaction.objectStore(this._objectStoreName);\r\n        const request = objectStore.getAll(idbQuery);\r\n        request.onsuccess = (e) => {\r\n          const result = request.result;\r\n          if (result) {\r\n            const documents = this.#parseQuery(query, result);\r\n            const keys = documents.map((document) => document._key);\r\n            // delete documents\r\n            this.#deleteByKeys(keys);\r\n          }\r\n          resolve();\r\n        };\r\n        request.onerror = (e) => {\r\n          reject(request.error);\r\n        };\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Deletes all documents\r\n   * @returns {Promise<void>}\r\n   */\r\n  async deleteAll() {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        if (!this._db) throw new Error(\"Database is not connected\");\r\n\r\n        const transaction = this._db.transaction(\r\n          this._objectStoreName,\r\n          \"readwrite\"\r\n        );\r\n        const objectStore = transaction.objectStore(this._objectStoreName);\r\n        const request = objectStore.clear();\r\n        request.onsuccess = (e) => {\r\n          resolve();\r\n        };\r\n        request.onerror = (e) => {\r\n          reject(request.error);\r\n        };\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Updates a document by its primary key\r\n   * @param {String} key\r\n   * @param {Object} object\r\n   * @returns {Promise<LeafstoreDocument<T>>}\r\n   */\r\n  async findByKeyAndUpdate(key, object) {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        if (!this._db) throw new Error(\"Database is not connected\");\r\n\r\n        if (!key) throw new Error(\"Key is required\");\r\n        if (!object) throw new Error(\"update object is required\");\r\n        if (typeof object !== \"object\") {\r\n          throw new Error(\"update object must be an object\");\r\n        }\r\n        // get original object\r\n        const transaction = this._db.transaction(\r\n          this._objectStoreName,\r\n          \"readwrite\"\r\n        );\r\n        const objectStore = transaction.objectStore(this._objectStoreName);\r\n        const request = objectStore.get(key);\r\n        request.onsuccess = (e) => {\r\n          let result = request.result;\r\n          [result] = this.#filterDeleted([result]);\r\n          if (result) {\r\n            let updatedObject = {\r\n              ...result,\r\n              ...(object || {}),\r\n            };\r\n            // validate and cast updated object\r\n            this._schema.validate(updatedObject);\r\n            updatedObject = this._schema.cast(updatedObject);\r\n            // add original key to object\r\n            updatedObject._key = key;\r\n            // update object\r\n            // no need to pass key since it is already in the object\r\n            // MDN: If the object store uses in-line keys and key is specified,\r\n            // DataError is thrown.\r\n            const updateRequest = objectStore.put(updatedObject);\r\n            updateRequest.onsuccess = () => {\r\n              resolve(new LeafstoreDocument(updatedObject, this, false));\r\n            };\r\n            updateRequest.onerror = () => {\r\n              reject(updateRequest.error);\r\n            };\r\n          } else {\r\n            reject(new Error(`No document found with key '${key}'`));\r\n          }\r\n          resolve(new LeafstoreDocument(object, this, false));\r\n        };\r\n        request.onerror = (e) => {\r\n          reject(request.error);\r\n        };\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Updates the first document matching the query\r\n   * @param {Object | IDBValidKey | IDBKeyRange | null} query - The query to match.\r\n   * @param {Object} object\r\n   * @returns {Promise<LeafstoreDocument<T>>}\r\n   */\r\n  async updateOne(query, object) {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        if (!this._db) throw new Error(\"Database is not connected\");\r\n\r\n        if (!object) throw new Error(\"update object is required\");\r\n        if (typeof object !== \"object\") {\r\n          throw new Error(\"update object must be an object\");\r\n        }\r\n        // Optimisation for primary key queries\r\n        let objectStoreName = this._objectStoreName;\r\n        let idbQuery = null;\r\n        if (typeof query === \"string\") {\r\n          idbQuery = query;\r\n        }\r\n        // optimisation ends\r\n        const transaction = this._db.transaction(\r\n          this._objectStoreName,\r\n          \"readwrite\"\r\n        );\r\n        const objectStore = transaction.objectStore(this._objectStoreName);\r\n        const request = objectStore.getAll(idbQuery);\r\n        request.onsuccess = (e) => {\r\n          const result = request.result;\r\n          if (result) {\r\n            const document = this.#parseQuery(query, result, true);\r\n            if (document) {\r\n              const key = document._key;\r\n              let updatedObject = {\r\n                ...document,\r\n                ...(object || {}),\r\n              };\r\n              // validate and cast updated object\r\n              this._schema.validate(updatedObject);\r\n              updatedObject = this._schema.cast(updatedObject);\r\n              // add original key to object\r\n              updatedObject._key = key;\r\n              // update object\r\n              // no need to pass key since it is already in the object\r\n              // MDN: If the object store uses in-line keys and key is specified,\r\n              // DataError is thrown.\r\n              const updateRequest = objectStore.put(updatedObject);\r\n              updateRequest.onsuccess = () => {\r\n                resolve(new LeafstoreDocument(updatedObject, this, false));\r\n              };\r\n              updateRequest.onerror = () => {\r\n                reject(updateRequest.error);\r\n              };\r\n            } else {\r\n              reject(\r\n                new Error(`No document found with query '${query?.toString()}'`)\r\n              );\r\n            }\r\n          } else {\r\n            reject(\r\n              new Error(`No document found with query '${query?.toString()}'`)\r\n            );\r\n          }\r\n        };\r\n        request.onerror = (e) => {\r\n          reject(request.error);\r\n        };\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Updates all documents matching the query\r\n   * @param {Object | IDBValidKey | IDBKeyRange | null} query - The query to match.\r\n   * @param {Object} object\r\n   * @returns {Promise<LeafstoreDocument<T>[]>}\r\n   */\r\n  async updateMany(query, object) {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        if (!this._db) throw new Error(\"Database is not connected\");\r\n\r\n        if (!object) throw new Error(\"update object is required\");\r\n        if (typeof object !== \"object\") {\r\n          throw new Error(\"update object must be an object\");\r\n        }\r\n        // Optimisation for primary key queries\r\n        let objectStoreName = this._objectStoreName;\r\n        let idbQuery = null;\r\n        if (typeof query === \"string\") {\r\n          idbQuery = query;\r\n        }\r\n        // optimisation ends\r\n        const transaction = this._db.transaction(\r\n          this._objectStoreName,\r\n          \"readwrite\"\r\n        );\r\n        const objectStore = transaction.objectStore(this._objectStoreName);\r\n        const request = objectStore.getAll(idbQuery);\r\n        request.onsuccess = () => {\r\n          const result = request.result;\r\n          if (result) {\r\n            const documents = this.#parseQuery(query, result);\r\n            // update documents\r\n            documents.forEach((document) => {\r\n              let updatedObject = {\r\n                ...document,\r\n                ...(object || {}),\r\n              };\r\n              // validate and cast updated object\r\n              this._schema.validate(updatedObject);\r\n              updatedObject = this._schema.cast(updatedObject);\r\n              // add original key to object\r\n              updatedObject._key = document._key;\r\n              // update object\r\n              // no need to pass key since it is already in the object\r\n              // MDN: If the object store uses in-line keys and key is specified,\r\n              // DataError is thrown.\r\n              const updateRequest = objectStore.put(updatedObject);\r\n              updateRequest.onsuccess = () => {\r\n                resolve(\r\n                  documents.map(\r\n                    (object) => new LeafstoreDocument(object, this, false)\r\n                  )\r\n                );\r\n              };\r\n              updateRequest.onerror = () => {\r\n                reject(updateRequest.error);\r\n              };\r\n            });\r\n          } else {\r\n            resolve([]);\r\n          }\r\n        };\r\n        request.onerror = (e) => {\r\n          reject(request.error);\r\n        };\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Counts the number of documents matching the query\r\n   * @param {Object | IDBValidKey | IDBKeyRange | null} [query] - The query to match.\r\n   * @returns {Promise<Number>}\r\n   */\r\n  async count(query) {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        if (!this._db) throw new Error(\"Database is not connected\");\r\n\r\n        // Optimisation for primary key queries\r\n        let objectStoreName = this._objectStoreName;\r\n        let idbQuery = null;\r\n        if (typeof query === \"string\") {\r\n          idbQuery = query;\r\n        }\r\n        // optimisation ends\r\n        const transaction = this._db.transaction(objectStoreName, \"readonly\");\r\n        const objectStore = transaction.objectStore(this._objectStoreName);\r\n        const request = objectStore.getAll(idbQuery);\r\n        request.onsuccess = (e) => {\r\n          const result = request.result;\r\n          if (result) {\r\n            const documents = this.#parseQuery(query, result);\r\n            resolve(documents.length);\r\n          } else {\r\n            resolve(0);\r\n          }\r\n        };\r\n        request.onerror = (e) => {\r\n          reject(request.error);\r\n        };\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * filters documents by a query.\r\n   * Also filters deleted documents\r\n   * @param {Object} query - The query to match\r\n   * @param {Object[]} documents - The documents to filter\r\n   * @param {Boolean} [returnOne=false] - Whether to return on first match\r\n   * @returns {Object[] | Object | null}\r\n   */\r\n  #parseQuery(query, documents, returnOne = false) {\r\n    if (!query) return documents;\r\n\r\n    documents = this.#filterDeleted(documents);\r\n\r\n    /**\r\n     * @type {[String, Function][]}\r\n     */\r\n    const supportedOperators = [\r\n      [\"$eq\", (a, b) => a === b],\r\n      [\"$gt\", (a, b) => a > b],\r\n      [\"$gte\", (a, b) => a >= b],\r\n      [\"$lt\", (a, b) => a < b],\r\n      [\"$lte\", (a, b) => a <= b],\r\n      [\"$in\", (a, b) => b.includes(a)],\r\n      [\"$nin\", (a, b) => !b.includes(a)],\r\n      [\"$ne\", (a, b) => a !== b],\r\n      [\"$regex\", (a, b) => b.test(a)],\r\n    ];\r\n\r\n    const doesMatch = (document) => {\r\n      for (let key in query) {\r\n        if (query.hasOwnProperty(key)) {\r\n          if (!document.hasOwnProperty(key)) return false;\r\n          if (typeof query[key] === \"object\") {\r\n            for (let op in query[key]) {\r\n              if (query[key].hasOwnProperty(op)) {\r\n                const [operatorName, operatorFunc] = supportedOperators.find(\r\n                  (operator) => operator[0] === op\r\n                ) || [null, () => false];\r\n                if (!operatorName) {\r\n                  throw new Error(`Operator '${op}' is not supported`);\r\n                }\r\n                if (!operatorFunc(document[key], query[key][op])) {\r\n                  return false;\r\n                }\r\n              } else {\r\n                return false;\r\n              }\r\n            }\r\n          } else {\r\n            if (document[key] !== query[key]) return false;\r\n          }\r\n        }\r\n      }\r\n      return true;\r\n    };\r\n\r\n    if (returnOne) {\r\n      return documents.find(doesMatch);\r\n    }\r\n    return documents.filter(doesMatch);\r\n  }\r\n\r\n  /**\r\n   * Adds a unique key to an object\r\n   * @param {Object} object\r\n   * @returns {void}\r\n   */\r\n  #addUniqueKey(object) {\r\n    const timestamp = new Date().getTime();\r\n    const random = Math.floor(Math.random() * 1000000);\r\n    let key = `${timestamp}${random}`;\r\n    object[\"_key\"] = key;\r\n  }\r\n\r\n  /**\r\n   * Adds meta data to an object\r\n   * @param {Object} object\r\n   * @returns {void}\r\n   */\r\n  #addMetaData(object) {\r\n    // TODO: add meta data as per need\r\n    // currently not in use\r\n  }\r\n\r\n  /**\r\n   * Deletes multiple documents by their primary keys from the database.\r\n   * Non blocking. Uses a cache to store deleted keys.\r\n   * @param {String[]} keys\r\n   */\r\n  #deleteByKeys(keys) {\r\n    if (!keys) return;\r\n    try {\r\n      keys.forEach((key) => {\r\n        // timeout to make it non blocking\r\n        setTimeout(() => {\r\n          this.#deleteByKey(key);\r\n        }, 0);\r\n      });\r\n    } catch (error) {\r\n      // do nothing\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Deletes a document by its primary key from the database.\r\n   * Non blocking. Uses a cache to store deleted keys.\r\n   * @param {String} key\r\n   */\r\n  #deleteByKey(key) {\r\n    if (!key) return;\r\n    try {\r\n      if (!this._db) throw new Error(\"Database is not connected\");\r\n\r\n      const transaction = this._db.transaction(\r\n        this._objectStoreName,\r\n        \"readwrite\"\r\n      );\r\n      const objectStore = transaction.objectStore(this._objectStoreName);\r\n      const request = objectStore.delete(key);\r\n      request.onsuccess = (e) => {\r\n        // remove key from cache\r\n        this._deletedKeys = this._deletedKeys.filter((k) => k !== key);\r\n      };\r\n      request.onerror = (e) => {\r\n        // do nothing\r\n      };\r\n    } catch (error) {\r\n      // do nothing\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Filters deleted documents from a list of documents.\r\n   * @param {Object[]} documents\r\n   * @returns {Object[]}\r\n   */\r\n  #filterDeleted(documents) {\r\n    return documents.filter((document) => {\r\n      return !this._deletedKeys.includes(document?._key);\r\n    });\r\n  }\r\n}\r\n\r\n// module.exports = LeafstoreModel;\r\nexport default LeafstoreModel;\r\n","/**\r\n * @typedef {Object} LeafstoreSchemaOptions\r\n */\r\n\r\n/**\r\n * @template {Record<string, any>} T\r\n * @class\r\n */\r\nclass LeafstoreSchema {\r\n  /**\r\n   * Creates a Leafstore schema. This should not be called directly. Use {@link leafstore.Schema} instead.\r\n   * @param {T} object - The template object used to generate the schema.\r\n   * @param {LeafstoreSchemaOptions} options - Optional configuration for the schema.\r\n   */\r\n  constructor(object, options = {}) {\r\n    this._rawSchema = object;\r\n    this._schema = this.#generateSchema(object);\r\n  }\r\n\r\n  /**\r\n   * Generates a schema from the given template object.\r\n   * @param {Object} object - The template object used to generate the schema.\r\n   * @param {string | undefined} [name] - The name of the object.\r\n   * @returns {Object} The generated schema.\r\n   */\r\n  #generateSchema(object, name) {\r\n    // TODO: check logic again\r\n    let schema = {};\r\n    // add key to schema if root object\r\n    if (!name) {\r\n      schema = {\r\n        _key: {\r\n          _type: \"string\",\r\n          _validators: [],\r\n        },\r\n      };\r\n    }\r\n    for (let key in object) {\r\n      if (key === \"type\") {\r\n        const validators = this.#validators(object, name);\r\n        const isUnique = object.unique;\r\n        schema = {\r\n          _type: object[key],\r\n          _validators: validators,\r\n          _unique: isUnique,\r\n        };\r\n      } else if (object.hasOwnProperty(key)) {\r\n        const fieldProps = object[key];\r\n        if (typeof fieldProps === \"string\") {\r\n          schema[key] = {\r\n            _type: fieldProps,\r\n            _validators: [],\r\n          };\r\n        } else if (Array.isArray(fieldProps)) {\r\n          schema[key] = {\r\n            _type: \"array\",\r\n            _schema: this.#generateSchema(fieldProps[0], key),\r\n          };\r\n        } else if (typeof fieldProps === \"object\") {\r\n          schema[key] = this.#generateSchema(fieldProps, key);\r\n        }\r\n      }\r\n    }\r\n    return schema;\r\n  }\r\n\r\n  /**\r\n   * Generates validators for a field.\r\n   * @param {Object} fieldProps - The properties of the field.\r\n   * @param {string} [name] - The name of the field.\r\n   * @returns {Array<Function>} An array of validators.\r\n   */\r\n  #validators(fieldProps, name) {\r\n    const { required, minLength, maxLength, minValue, maxValue } = fieldProps;\r\n\r\n    const validators = [];\r\n\r\n    const requiredValidator = (value) => {\r\n      if (required && !value) throw new Error(`${name} is required`);\r\n    };\r\n\r\n    const minLengthValidator = (value) => {\r\n      // validator format\r\n      // minLength: 4 OR minLength: [4, \"error message\"]\r\n      let message;\r\n      if (Array.isArray(minLength)) {\r\n        let [length, _message] = minLength;\r\n        message = _message;\r\n        if (typeof length !== \"number\")\r\n          throw new Error(`Invalid minLength value for ${name}`);\r\n        if (typeof message !== \"string\")\r\n          message = `length of ${name} must be at least ${length}`;\r\n      } else {\r\n        if (typeof minLength !== \"number\")\r\n          throw new Error(`Invalid minLength value for ${name}`);\r\n        message = `length of ${name} must be at least ${minLength}`;\r\n      }\r\n      if (value?.length < minLength) throw new Error(message);\r\n      return true;\r\n    };\r\n\r\n    const maxLengthValidator = (value) => {\r\n      // validator format\r\n      // maxLength: 4 OR maxLength: [4, \"error message\"]\r\n      let message;\r\n      if (Array.isArray(maxLength)) {\r\n        let [length, _message] = maxLength;\r\n        message = _message;\r\n        if (typeof length !== \"number\")\r\n          throw new Error(`Invalid maxLength value for ${name}`);\r\n        if (typeof message !== \"string\")\r\n          message = `Length of ${name} must be at most ${length}`;\r\n      } else {\r\n        if (typeof maxLength !== \"number\")\r\n          throw new Error(`Invalid maxLength value for ${name}`);\r\n        message = `Length of ${name} must be at most ${maxLength}`;\r\n      }\r\n      if (value?.length > maxLength) throw new Error(message);\r\n      return true;\r\n    };\r\n\r\n    const minValueValidator = (value) => {\r\n      // validator format\r\n      // minValue: 4 OR minValue: [4, \"error message\"]\r\n      let message;\r\n      if (Array.isArray(minValue)) {\r\n        let [value, _message] = minValue;\r\n        message = _message;\r\n        if (typeof value !== \"number\")\r\n          throw new Error(`Invalid minValue value for ${name}`);\r\n        if (typeof message !== \"string\")\r\n          message = `${name} must be at least ${value}`;\r\n      } else {\r\n        if (typeof minValue !== \"number\")\r\n          throw new Error(`Invalid minValue value for ${name}`);\r\n        message = `${name} must be at least ${minValue}`;\r\n      }\r\n      if (value < minValue) throw new Error(message);\r\n      return true;\r\n    };\r\n\r\n    const maxValueValidator = (value) => {\r\n      // validator format\r\n      // maxValue: 4 OR maxValue: [4, \"error message\"]\r\n      let message;\r\n      if (Array.isArray(maxValue)) {\r\n        let [value, _message] = maxValue;\r\n        message = _message;\r\n        if (typeof value !== \"number\")\r\n          throw new Error(`Invalid maxValue value for ${name}`);\r\n        if (typeof message !== \"string\")\r\n          message = `${name} must be at most ${value}`;\r\n      } else {\r\n        if (typeof maxValue !== \"number\")\r\n          throw new Error(`Invalid maxValue value for ${name}`);\r\n        message = `${name} must be at most ${maxValue}`;\r\n      }\r\n      if (value > maxValue) throw new Error(message);\r\n      return true;\r\n    };\r\n\r\n    // add validators to array\r\n    if (required) validators.push(requiredValidator);\r\n    if (minLength && typeof minLength === \"number\")\r\n      validators.push(minLengthValidator);\r\n    if (maxLength && typeof maxLength === \"number\")\r\n      validators.push(maxLengthValidator);\r\n    if (minValue && typeof minValue === \"number\")\r\n      validators.push(minValueValidator);\r\n    if (maxValue && typeof maxValue === \"number\")\r\n      validators.push(maxValueValidator);\r\n\r\n    return validators;\r\n  }\r\n\r\n  /**\r\n   * Validates an object against the schema.\r\n   * @param {Object} object - The object to validate.\r\n   * @returns {void}\r\n   * @throws {Error} Throws an error if the object is invalid.\r\n   */\r\n  validate(object) {\r\n    this.#validateObject(object, this._schema);\r\n  }\r\n\r\n  /**\r\n   * Validates an object against the schema.\r\n   * @param {Object} object - The object to validate.\r\n   * @param {Object} schema - The schema to validate against.\r\n   * @returns {void}\r\n   * @throws {Error} Throws an error if the object is invalid.\r\n   */\r\n  #validateObject(object, schema) {\r\n    // TODO: check logic again\r\n    for (let key in schema) {\r\n      if (schema.hasOwnProperty(key)) {\r\n        const fieldProps = schema[key];\r\n        if (fieldProps._type === \"array\") {\r\n          if (!object[key]) object[key] = []; // default value for array\r\n          if (Array.isArray(object[key])) {\r\n            object[key].forEach((item) => {\r\n              this.#validateObject(item, fieldProps._schema);\r\n            });\r\n          } else {\r\n            throw new Error(`'${key}' must be an array`);\r\n          }\r\n        } else if (fieldProps._type === \"object\") {\r\n          this.#validateObject(object[key], fieldProps);\r\n        } else {\r\n          fieldProps._validators?.forEach((validator) => {\r\n            validator(object[key]);\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Casts an object to the schema.\r\n   * @param {Object} object - The object to cast.\r\n   * @returns {Object} The casted object.\r\n   * @throws {Error} Throws an error if the object is invalid.\r\n   */\r\n  cast(object) {\r\n    return this.#cast(object, this._schema);\r\n  }\r\n\r\n  /**\r\n   * Casts an object to the schema.\r\n   * @param {Object} object - The object to cast.\r\n   * @param {Object} schema - The schema to cast against.\r\n   * @returns {Object} The casted object.\r\n   * @throws {Error} Throws an error if the object is invalid.\r\n   */\r\n  #cast(object, schema) {\r\n    let result = {};\r\n    for (let key in schema) {\r\n      if (schema.hasOwnProperty(key)) {\r\n        const fieldProps = schema[key];\r\n        if (fieldProps._type === \"array\") {\r\n          if (!object[key]) object[key] = []; // default value for array\r\n          if (Array.isArray(object[key])) {\r\n            result[key] = object[key].map((item) => {\r\n              return this.#cast(item, fieldProps._schema);\r\n            });\r\n          } else {\r\n            throw new Error(`'${key}' must be an array`);\r\n          }\r\n        } else if (fieldProps._type === \"object\") {\r\n          result[key] = this.#cast(object[key], fieldProps);\r\n        } else {\r\n          result[key] = object[key];\r\n        }\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n}\r\n\r\n// module.exports = LeafstoreSchema;\r\nexport default LeafstoreSchema;\r\n","console.log(\"Extension loaded\");\r\n\r\nconst fetchUrl = \"https://cses-marker.onrender.com\";\r\n\r\nimport leafstore from \"leafstore-db\";\r\n\r\nconst db = new leafstore(\"CSES_MARKER_EXTENSION_DB\");\r\n\r\nconst problemSchema = leafstore.Schema({\r\n  _id: {\r\n    type: leafstore.SchemaTypes.String,\r\n    required: false,\r\n  },\r\n  problemName: leafstore.SchemaTypes.String,\r\n  problemId: leafstore.SchemaTypes.String,\r\n  isImportant: leafstore.SchemaTypes.Boolean,\r\n  message: leafstore.SchemaTypes.String,\r\n  user: leafstore.SchemaTypes.String,\r\n  group: leafstore.SchemaTypes.String,\r\n  username: leafstore.SchemaTypes.String,\r\n});\r\n\r\nconst userSchema = leafstore.Schema({\r\n  _id: leafstore.SchemaTypes.String,\r\n  email: leafstore.SchemaTypes.String,\r\n  username: leafstore.SchemaTypes.String,\r\n  password: leafstore.SchemaTypes.String,\r\n  sorting: leafstore.SchemaTypes.String,\r\n  filter: leafstore.SchemaTypes.String,\r\n  groupJoined: leafstore.SchemaTypes.String,\r\n  questions: [\r\n    {\r\n      _id: {\r\n        type: leafstore.SchemaTypes.String,\r\n        required: false,\r\n      },\r\n      problemName: leafstore.SchemaTypes.String,\r\n      problemId: leafstore.SchemaTypes.String,\r\n      isImportant: leafstore.SchemaTypes.Boolean,\r\n      message: leafstore.SchemaTypes.String,\r\n      user: leafstore.SchemaTypes.String,\r\n      group: leafstore.SchemaTypes.String,\r\n      username: leafstore.SchemaTypes.String,\r\n    },\r\n  ],\r\n});\r\nconst User = db.Model(\"User\", userSchema);\r\nconst Problem = db.Model(\"Problem\", problemSchema);\r\n\r\n//   DIV1\r\n// insert a div before content class div into the DOM\r\nconst div1 = document.createElement(\"div\");\r\ndiv1.id = \"cses-marker-extension-root-1\";\r\n// div.style.display = \"none\";\r\nconst contentDiv = document.querySelector(\".content\");\r\ncontentDiv.insertBefore(div1, contentDiv.firstChild);\r\ndiv1.innerHTML = `\r\n<button id=\"cses-marker-click-to-login-button\">Click to LogIn</button>\r\n`;\r\n\r\n//   DIV2\r\nconst div2 = document.createElement(\"div\");\r\ndiv2.id = \"cses-marker-extension-root-2\";\r\ndiv2.style.display = \"none\";\r\nconst contentDiv2 = document.querySelector(\".content\");\r\ncontentDiv2.insertBefore(div2, contentDiv2.firstChild);\r\ndiv2.innerHTML = `\r\nusername: <input id=\"username\" type=\"text\" /> password: <input id=\"password\" type=\"password\" /> <button id=\"cses-marker-login-button\">LogIn</button>\r\n`;\r\n\r\n//   DIV3\r\nconst div3 = document.createElement(\"div\");\r\ndiv3.id = \"cses-marker-extension-root-3\";\r\ndiv3.style.display = \"none\";\r\nconst contentDiv3 = document.querySelector(\".content\");\r\ncontentDiv2.insertBefore(div3, contentDiv3.firstChild);\r\ndiv3.innerHTML = `<button id=\"cses-marker-display-username\"></button>\r\n<button id=\"cses-marker-sync-button\">Sync</button><button id=\"cses-marker-logout-button\">LogOut</button>\r\n`;\r\n\r\n//                DIV OVER\r\n\r\n// Connect to the database\r\ntry {\r\n  await db.connect({\r\n    version: 1,\r\n    onUpgrade: (db) => {\r\n      console.log(\"Upgrading the database\");\r\n    },\r\n  });\r\n  console.log(\"Connected to the database\");\r\n  const user = await User.findOne({});\r\n  if (user) {\r\n    //       ADDING MARK IMPORTANT BUTTON CHECKBOX BEFORE A TASK TAG\r\n    const TASK_LI_ELEMENT = document.querySelectorAll(\".task\");\r\n    TASK_LI_ELEMENT.forEach((taskElement) => {\r\n      const checkboxDiv = document.createElement(\"div\");\r\n      checkboxDiv.className = \"checkbox\";\r\n      const checkboxInput = document.createElement(\"input\");\r\n      checkboxInput.type = \"checkbox\";\r\n      const anchorElement = taskElement.querySelector(\"a\");\r\n      if (anchorElement) {\r\n        // Extract href attribute\r\n        checkboxInput.className = \"cses-marker-checkbox\";\r\n        const hrefAttribute = anchorElement.getAttribute(\"href\");\r\n        checkboxInput.dataset.problemId = hrefAttribute;\r\n        checkboxInput.dataset.problemName =\r\n          anchorElement.innerText || anchorElement.textContent;\r\n      }\r\n      checkboxDiv.appendChild(checkboxInput);\r\n      taskElement.insertBefore(checkboxDiv, taskElement.firstChild);\r\n    });\r\n    document.querySelector(\"#cses-marker-display-username\").innerText =\r\n      user.username;\r\n    div1.style.display = \"none\";\r\n    div3.style.display = \"block\";\r\n    const problemsArray = await Problem.find({});\r\n    problemsArray.forEach((problem) => {\r\n      const checkbox = document.querySelector(\r\n        `[data-problem-id=\"${problem.problemId}\"]`\r\n      );\r\n      if (!checkbox) return;\r\n      // make whole task div green\r\n      const taskDiv = checkbox.parentElement.parentElement;\r\n      const anchorElement =\r\n        checkbox.parentElement.parentElement.querySelector(\"a\");\r\n      if (problem.isImportant) {\r\n        taskDiv.style.backgroundColor = \"lightyellow\";\r\n        anchorElement.style.fontWeight = \"bold\";\r\n      } else {\r\n        taskDiv.style.backgroundColor = \"white\";\r\n      }\r\n      // make checkbox checked\r\n      if (checkbox && problem.user === user._id && problem.isImportant) {\r\n        checkbox.checked = problem.isImportant;\r\n        // make anchor tag Red and bold\r\n        if (anchorElement) {\r\n          anchorElement.style.color = \"red\";\r\n          anchorElement.style.fontWeight = \"bold\";\r\n        }\r\n      }\r\n    });\r\n    const navSlidebar = document.querySelector(\".nav.sidebar\");\r\n    if (navSlidebar) {\r\n      const url = window.location.href;\r\n      const urlArray = url.split(\"/\");\r\n      const problemId =\r\n        \"/\" +\r\n        urlArray[urlArray.length - 3] +\r\n        \"/\" +\r\n        urlArray[urlArray.length - 2] +\r\n        \"/\" +\r\n        urlArray[urlArray.length - 1];\r\n      // creating a mark important checkbox at the top to add to the sidebar\r\n      const checkboxDiv = document.createElement(\"div\");\r\n      checkboxDiv.className = \"checkbox\";\r\n      checkboxDiv.style.width = \"100%\";\r\n      checkboxDiv.style.border = \"1px solid #ccc\";\r\n      checkboxDiv.style.padding = \"3px\";\r\n      checkboxDiv.style.margin = \"5px\";\r\n      checkboxDiv.style.borderRadius = \"5px\";\r\n      checkboxDiv.style.backgroundColor = \"#f1f1f1\";\r\n      checkboxDiv.style.boxShadow = \"0 0 10px #ccc\";\r\n      const checkboxInput = document.createElement(\"input\");\r\n      checkboxInput.type = \"checkbox\";\r\n      checkboxInput.className = \"cses-marker-checkbox\";\r\n      checkboxInput.dataset.problemId = problemId;\r\n      checkboxInput.dataset.problemName = document\r\n        .querySelector(\".title-block\")\r\n        .getElementsByTagName(\"h1\")[0].innerText;\r\n\r\n      const problemToCheck = await Problem.findOne({\r\n        problemId: problemId,\r\n        user: user._id,\r\n      });\r\n      if (problemToCheck !== null && problemToCheck.isImportant) {\r\n        checkboxInput.checked = true;\r\n      }\r\n      checkboxDiv.innerHTML += `<label for=\"cses-marker-checkbox\" style=\"font-weight: bold; display: block; margin-bottom: 2px\">Mark Important</label>`;\r\n      checkboxDiv.appendChild(checkboxInput);\r\n      navSlidebar.insertBefore(checkboxDiv, navSlidebar.firstChild);\r\n\r\n      // creating a comment div at the top to add to the sidebar\r\n      const commentDiv = document.createElement(\"div\");\r\n      commentDiv.className = \"comment\";\r\n      const problem = await Problem.findOne({\r\n        problemId: problemId,\r\n        user: user._id,\r\n      });\r\n      commentDiv.innerHTML = `<div class=\"comment-container\" style=\"width:100%;\">\r\n      <div\r\n      class=\"comment\"\r\n      style=\"\r\n      width:100%;\r\n      border: 1px solid #ccc;\r\n          padding: 3px;\r\n          margin: 5px;\r\n          border-radius: 5px;\r\n          background-color: #f1f1f1;\r\n          box-shadow: 0 0 10px #ccc;\r\n          \"\r\n          >\r\n          <label\r\n          for=\"comment-textarea\"\r\n          class=\"comment-author\"\r\n          style=\"font-weight: bold; display: block; margin-bottom: 2px\"\r\n          >${user.username}</label\r\n        >\r\n        <textarea\r\n        name=\"comment\"\r\n          id=\"cses-marker-comment-input\"\r\n          cols=\"30\"\r\n          rows=\"10\"\r\n          style=\"\r\n          width: 99%;\r\n          height: 150px;\r\n          border: 1px solid #ccc;\r\n          border-radius: 5px;\r\n          padding: 5px;\r\n            margin: 2px 0;\r\n            \"\r\n            >${problem !== null ? problem.message : \"\"}\r\n            </textarea>\r\n        <button\r\n        id=\"cses-marker-comment-button\"\r\n          style=\"\r\n          border: 1px solid #ccc;\r\n          border-radius: 5px;\r\n          padding: 5px;\r\n          margin: 2px 0;\r\n          background-color: #fff;\r\n          cursor: pointer;\r\n          font-weight: bold;\r\n          \"\r\n          >\r\n          Comment\r\n        </button>\r\n        </div>\r\n    </div>`;\r\n      navSlidebar.insertBefore(commentDiv, navSlidebar.firstChild);\r\n      // showing comments as a list\r\n      //print url of the problem\r\n      const commentsList = document.createElement(\"div\");\r\n      commentsList.className = \"comment\";\r\n      const comments = await Problem.find({\r\n        problemId: problemId,\r\n      });\r\n      comments.forEach((comment) => {\r\n        const commentElement = document.createElement(\"div\");\r\n        commentElement.innerHTML = `<div class=\"comment-container\" style=\"width:100%;\">\r\n        <div\r\n        class=\"comment\"\r\n            style=\"\r\n            width:100%;\r\n              border: 1px solid #ccc;\r\n              padding: 3px;\r\n              margin: 5px;\r\n              border-radius: 5px;\r\n              background-color: #f1f1f1;\r\n              box-shadow: 0 0 10px #ccc;\r\n              \"\r\n              >\r\n              <b>${comment.username}</b>: <br> ${comment.message}\r\n              </div>\r\n            </div>`;\r\n        commentsList.appendChild(commentElement);\r\n      });\r\n      navSlidebar.insertBefore(commentsList, navSlidebar.firstChild);\r\n\r\n      // adding event listener to comment button\r\n      document\r\n        .querySelector(\"#cses-marker-comment-button\")\r\n        .addEventListener(\"click\", async () => {\r\n          const comment = document.querySelector(\r\n            \"#cses-marker-comment-input\"\r\n          ).value;\r\n          // clear the input\r\n          document.querySelector(\"#cses-marker-comment-input\").value = \"\";\r\n          if (comment === \"\") return;\r\n          const problemName = document\r\n            .querySelector(\".title-block\")\r\n            .getElementsByTagName(\"h1\")[0].innerText;\r\n          const problem = await Problem.findOne({\r\n            problemId: problemId,\r\n            user: user._id,\r\n          });\r\n          if (problem === null) {\r\n            const problem = {\r\n              problemId: problemId,\r\n              problemName: problemName,\r\n              isImportant: false,\r\n              message: comment,\r\n              user: user._id,\r\n              username: user.username,\r\n            };\r\n            if (user.groupJoined !== undefined && user.groupJoined !== \"\") {\r\n              problem.group = user.groupJoined;\r\n            }\r\n            const newProblem = await Problem.create(problem);\r\n            const commentElement = document.createElement(\"div\");\r\n            commentElement.innerHTML = `<div class=\"comment-container\" style=\"width:100%;\">\r\n          <div\r\n          class=\"comment\"\r\n            style=\"\r\n            width:100%;\r\n            border: 1px solid #ccc;\r\n            padding: 3px;\r\n            margin: 5px;\r\n            border-radius: 5px;\r\n              background-color: #f1f1f1;\r\n              box-shadow: 0 0 10px #ccc;\r\n              \"\r\n              >\r\n          ${problem.username} : ${problem.message}\r\n          </div>\r\n            </div>`;\r\n            commentsList.insertBefore(commentElement, commentsList.firstChild);\r\n            // adding problem to user\r\n            user.questions = [...user.questions, problem];\r\n            await user.save();\r\n            return;\r\n          }\r\n          problem.message = comment;\r\n          await problem.save();\r\n          const commentElement = document.createElement(\"div\");\r\n          commentElement.innerHTML = `<div class=\"comment-container\" style=\"width:100%;\">\r\n          <div\r\n            class=\"comment\"\r\n            style=\"\r\n              width:100%;\r\n              border: 1px solid #ccc;\r\n              padding: 3px;\r\n              margin: 5px;\r\n              border-radius: 5px;\r\n              background-color: #f1f1f1;\r\n              box-shadow: 0 0 10px #ccc;\r\n              \"\r\n          >\r\n          ${problem.username} : ${problem.message}\r\n            </div>\r\n            </div>`;\r\n          commentsList.insertBefore(commentElement, commentsList.firstChild);\r\n          // adding problem to user\r\n          const questions = [];\r\n          for (let i = 0; i < user.questions.length; i++) {\r\n            if (user.questions[i].problemId === problemId) {\r\n              user.questions[i].message = comment;\r\n            }\r\n            questions.push(user.questions[i]);\r\n          }\r\n          user.questions = questions;\r\n          await user.save();\r\n          // reload the page\r\n          window.location.reload();\r\n        });\r\n    }\r\n  }\r\n} catch (error) {\r\n  console.log(\r\n    \"Error connecting to the INDEX DB database. Please try again.\" + error\r\n  );\r\n  await User.deleteAll();\r\n  await Problem.deleteAll();\r\n  console.log(error);\r\n}\r\n\r\n//            EVENT LISTENERS\r\n\r\n//      OPEN DILOGUE BOX TO LOGIN\r\ndocument\r\n  .querySelector(\"#cses-marker-click-to-login-button\")\r\n  .addEventListener(\"click\", () => {\r\n    div1.style.display = \"none\";\r\n    div2.style.display = \"block\";\r\n  });\r\n\r\n//      MAKE LOGIN REQUEST AND SYNC BUTTON IS LOADED\r\ndocument\r\n  .querySelector(\"#cses-marker-login-button\")\r\n  .addEventListener(\"click\", () => {\r\n    const username = document.querySelector(\"#username\").value;\r\n    const password = document.querySelector(\"#password\").value;\r\n    if (username === \"\" || password === \"\") return;\r\n    fetch(fetchUrl + \"/userLogin\", {\r\n      method: \"POST\",\r\n      headers: {\r\n        \"Content-Type\": \"application/json\",\r\n        // Include any other headers if needed\r\n      },\r\n      body: JSON.stringify({\r\n        username: username,\r\n        password: password,\r\n        // Include other parameters in the request body as needed\r\n      }),\r\n    })\r\n      .then((response) => {\r\n        if (!response.ok) {\r\n          throw new Error(`HTTP error! Status: ${response.status}`);\r\n        }\r\n        return response.json();\r\n      })\r\n      .then((data) => {\r\n        if (data.success === true) {\r\n          div2.style.display = \"none\";\r\n          div3.style.display = \"block\";\r\n          data.problems.forEach((problem) => {\r\n            Problem.create(problem);\r\n          });\r\n          User.create(data.user);\r\n          // reload the page\r\n          window.location.reload();\r\n        }\r\n      })\r\n      .catch((error) => {\r\n        // Handle errors\r\n        console.error(\"Fetch error:\", error);\r\n      });\r\n  });\r\n\r\n//      SYNC BUTTON\r\ndocument\r\n  .querySelector(\"#cses-marker-sync-button\")\r\n  .addEventListener(\"click\", () => {\r\n    sync();\r\n  });\r\n\r\nconst sync = async () => {\r\n  const users = await User.find({});\r\n  if (users.length === 0) return;\r\n  const user = users[0]._object;\r\n  fetch(fetchUrl + \"/sync\", {\r\n    method: \"POST\",\r\n    headers: {\r\n      \"Content-Type\": \"application/json\",\r\n      // Include any other headers if needed\r\n    },\r\n    body: JSON.stringify({\r\n      user: user,\r\n      // Include other parameters in the request body as needed\r\n    }),\r\n  })\r\n    .then((response) => {\r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! Status: ${response.status}`);\r\n      }\r\n      return response.json();\r\n    })\r\n    .then(async (data) => {\r\n      await User.deleteAll();\r\n      await Problem.deleteAll();\r\n      // Handle the response data\r\n      data.problems.forEach((problem) => {\r\n        Problem.create(problem);\r\n      });\r\n      User.create(data.user);\r\n      // reload the page\r\n      window.location.reload();\r\n    })\r\n    .catch((error) => {\r\n      // Handle errors\r\n      console.error(\"Fetch error:\", error);\r\n    });\r\n};\r\n\r\ndocument\r\n  .querySelector(\"#cses-marker-logout-button\")\r\n  .addEventListener(\"click\", async () => {\r\n    await User.deleteAll();\r\n    await Problem.deleteAll();\r\n    window.location.reload();\r\n  });\r\n\r\n//    ADDING EVENT LISTENER TO CHECKBOXES\r\nconst checkboxes = document.querySelectorAll(\".cses-marker-checkbox\");\r\ncheckboxes.forEach((checkbox) => {\r\n  checkbox.addEventListener(\"change\", async (event) => {\r\n    const users = await User.find({});\r\n    if (users.length === 0) return;\r\n    const user = users[0];\r\n    let flag = false;\r\n    const checked = event.target.checked;\r\n    const questions = [];\r\n    for (let i = 0; i < user.questions.length; i++) {\r\n      if (user.questions[i].problemId === event.target.dataset.problemId) {\r\n        flag = true;\r\n        user.questions[i].isImportant = checked;\r\n        const ProblemInProblem = await Problem.findOne({\r\n          problemId: event.target.dataset.problemId,\r\n          user: user._id,\r\n        });\r\n        ProblemInProblem.isImportant = checked;\r\n        await ProblemInProblem.save();\r\n      }\r\n      questions.push(user.questions[i]);\r\n    }\r\n    user.questions = questions;\r\n    if (!flag) {\r\n      const problem = {\r\n        problemId: event.target.dataset.problemId,\r\n        problemName: event.target.dataset.problemName,\r\n        isImportant: checked,\r\n        message: \"\",\r\n        user: user._id,\r\n        username: user.username,\r\n      };\r\n      if (user.groupJoined !== \"\") {\r\n        problem.group = user.groupJoined;\r\n      }\r\n      const newProblem = await Problem.create(problem);\r\n      user.questions = [...user.questions, problem];\r\n    }\r\n    await user.save();\r\n    window.location.reload();\r\n  });\r\n});\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","var webpackQueues = typeof Symbol === \"function\" ? Symbol(\"webpack queues\") : \"__webpack_queues__\";\nvar webpackExports = typeof Symbol === \"function\" ? Symbol(\"webpack exports\") : \"__webpack_exports__\";\nvar webpackError = typeof Symbol === \"function\" ? Symbol(\"webpack error\") : \"__webpack_error__\";\nvar resolveQueue = (queue) => {\n\tif(queue && queue.d < 1) {\n\t\tqueue.d = 1;\n\t\tqueue.forEach((fn) => (fn.r--));\n\t\tqueue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));\n\t}\n}\nvar wrapDeps = (deps) => (deps.map((dep) => {\n\tif(dep !== null && typeof dep === \"object\") {\n\t\tif(dep[webpackQueues]) return dep;\n\t\tif(dep.then) {\n\t\t\tvar queue = [];\n\t\t\tqueue.d = 0;\n\t\t\tdep.then((r) => {\n\t\t\t\tobj[webpackExports] = r;\n\t\t\t\tresolveQueue(queue);\n\t\t\t}, (e) => {\n\t\t\t\tobj[webpackError] = e;\n\t\t\t\tresolveQueue(queue);\n\t\t\t});\n\t\t\tvar obj = {};\n\t\t\tobj[webpackQueues] = (fn) => (fn(queue));\n\t\t\treturn obj;\n\t\t}\n\t}\n\tvar ret = {};\n\tret[webpackQueues] = x => {};\n\tret[webpackExports] = dep;\n\treturn ret;\n}));\n__webpack_require__.a = (module, body, hasAwait) => {\n\tvar queue;\n\thasAwait && ((queue = []).d = -1);\n\tvar depQueues = new Set();\n\tvar exports = module.exports;\n\tvar currentDeps;\n\tvar outerResolve;\n\tvar reject;\n\tvar promise = new Promise((resolve, rej) => {\n\t\treject = rej;\n\t\touterResolve = resolve;\n\t});\n\tpromise[webpackExports] = exports;\n\tpromise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise[\"catch\"](x => {}));\n\tmodule.exports = promise;\n\tbody((deps) => {\n\t\tcurrentDeps = wrapDeps(deps);\n\t\tvar fn;\n\t\tvar getResult = () => (currentDeps.map((d) => {\n\t\t\tif(d[webpackError]) throw d[webpackError];\n\t\t\treturn d[webpackExports];\n\t\t}))\n\t\tvar promise = new Promise((resolve) => {\n\t\t\tfn = () => (resolve(getResult));\n\t\t\tfn.r = 0;\n\t\t\tvar fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));\n\t\t\tcurrentDeps.map((dep) => (dep[webpackQueues](fnQueue)));\n\t\t});\n\t\treturn fn.r ? promise : getResult();\n\t}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));\n\tqueue && queue.d < 0 && (queue.d = 0);\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n// This entry module used 'module' so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/content.js\");\n",""],"names":[],"sourceRoot":""}